AddCSLuaFile("cl_init.lua")AddCSLuaFile("shared.lua")include("shared.lua")GM:SetGNWVar("UseLives",false)GM:SetGNWVar("ServerName",GetConVarString("hostname"))GM:SetGNWFloat("MapEndTime",1200)local function updateservername(CVar,PreviousValue,NewValue)	GM:SetGNWVar("ServerName",NewValue)endcvars.AddChangeCallback("hostname",updateservername)function GM:Initialize()	endfunction GM:InitPostEntity()	self:RemoveVPhysEntities()	local mapinfo = game.GetMap() --get the name of the map	mapinfo = string.gsub(mapinfo,"(%w*/)","")	mapinfo = string.gsub(mapinfo,".bsp","")	self.Loader = NewGLoader("scavdata/maps/"..mapinfo.."/"..GetConVarString("sdm_settingsfile"))	self.Loader:ParseGameVars()	self.Loader:Spawn()	self.BaseClass:InitPostEntity()	timer.Simple(15, function() self:StartRound() end)endfunction GM:RemoveVPhysEntities()	for k,v in pairs(ents.GetAll()) do		if v:GetMoveType() == MOVETYPE_VPHYSICS then			v:Remove()		end	endendfunction GM:DoSetup()	self:RemoveVPhysEntities()	self.Loader:Spawn()endfunction GM:GetGameVar(var)	return self.Loader.data.gamevars[var]endfunction GM:SetGameVar(var,value)	self.Loader.data.gamevars[var] = value	hook.Call("GameVar",self,var,value)endlocal modetranslate = {["deathmatch"] = SDM_MODE_DM,["team_deathmatch"] = SDM_MODE_DM_TEAM,["ctf"] = SDM_MODE_CTF,["cell_control"] = SDM_MODE_CELLCONTROL,["hoard"] = SDM_MODE_HOARD,["survival"] = SDM_MODE_SURVIVAL,["capture"] = SDM_MODE_CAPTURE,["custom"] = SDM_MODE_CUSTOM}function GM:GameVar(key,value) --This function is called when the gamemode reads the game vars from a GLoader file. This is used to determine how each gamevar is used, like networking it for example.	--print("handling gamevar: ["..key.."] "..tostring(value))	key = string.lower(key)	if key == "mode" then		self:SetGNWVar("mode",modetranslate[string.lower(value)] or 0)	elseif key == "timelimit" then		self:SetGNWFloat("TimeLimit",value)		return tonumber(value)	elseif key == "mapendtime" then		self:SetGNWFloat("MapEndTime",value)		return tonumber(value)	elseif key == "maxpoints" then		self:SetGameVar("PointLimit",value)		return tonumber(value)	elseif key == "pointlimit" then		self:SetGNWFloat("PointLimit",value)		return tonumber(value)	endendfunction GM:EntityTakeDamage(ent,dmginfo)	local inflictor = dmginfo:GetInflictor()	local attacker = dmginfo:GetAttacker()	local amount = dmginfo:GetDamage()	if ent:IsPlayer() then		if attacker:IsPlayer() then			umsg.Start("sdm_pldmged",attacker)				umsg.Entity(ent)			umsg.End()		end		ent:GetCharacter():HandlePain(ent,dmginfo)	end	returnend--[[function PLAYER:MakePainSound(dmginfo,forceplay) --forceplay will force the sound to play if the player is ready to emit the sound	local inflictor = dmginfo:GetInflictor()	local attacker = dmginfo:GetAttacker()	local amt = dmginfo:GetDamage()	if dmginfo:GetDamageType() == DMG_DROWN then		return	end	if inflictor:IsValid() and (inflictor:GetClass() == "entityflame") and (not self.lastpaintime or (self.lastpaintime < CurTime()-1.25)) then		local model = ScavData.FormatModelname(self:GetModel())		local modeltype = PlayerModelTypes[model]		if modeltype then			local painno = #PlayerSounds.Pain[modeltype]			painno = math.Clamp(painno+math.random(-1,1),1,painno)			self:EmitSound(PlayerSounds.Pain[modeltype][painno])			self:ClearSoundQueue()		end		self.lastpaintime = CurTime()	elseif (not self.lastpaintime or (self.lastpaintime < CurTime()-1.5)) and (amt < self:Health()) and (forceplay or (amt-math.random(1,49) > 0)) then		local model = ScavData.FormatModelname(self:GetModel())		local modeltype = PlayerModelTypes[model]		if modeltype then			local painno = #PlayerSounds.Pain[modeltype]			painno = math.Clamp(math.floor(amt/5)+math.random(-1,1),1,painno)			self:PlaySDMSound("Pain",true,)			self:ClearSoundQueue()		end		self.lastpaintime = CurTime()	endendlocal function painsounds(ent,dmginfo)	if ent:IsPlayer() then		ent:MakePainSound(dmginfo,false)	endendhook.Add("EntityTakeDamage","painsounds",painsounds)]]